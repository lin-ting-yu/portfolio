{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Injectable, InjectionToken, PLATFORM_ID, Inject, Optional, SkipSelf, Component, Input, NgModule } from '@angular/core';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport { of, throwError } from 'rxjs';\nimport { map, tap, catchError, finalize, share } from 'rxjs/operators';\nimport * as i1 from '@angular/common/http';\nconst _c0 = [\"*\"];\n\nclass SvgLoader {}\n\nlet SvgHttpLoader = /*#__PURE__*/(() => {\n  class SvgHttpLoader extends SvgLoader {\n    constructor(http) {\n      super();\n      this.http = http;\n    }\n\n    getSvg(url) {\n      return this.http.get(url, {\n        responseType: 'text'\n      });\n    }\n\n  }\n\n  SvgHttpLoader.ɵfac = function SvgHttpLoader_Factory(t) {\n    return new (t || SvgHttpLoader)(i0.ɵɵinject(i1.HttpClient));\n  };\n\n  SvgHttpLoader.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: SvgHttpLoader,\n    factory: SvgHttpLoader.ɵfac\n  });\n  return SvgHttpLoader;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst SERVER_URL = new InjectionToken('SERVER_URL');\nlet SvgIconRegistryService = /*#__PURE__*/(() => {\n  class SvgIconRegistryService {\n    constructor(loader, platformId, serverUrl, _document) {\n      this.loader = loader;\n      this.platformId = platformId;\n      this.serverUrl = serverUrl;\n      this._document = _document;\n      this.iconsByUrl = new Map();\n      this.iconsLoadingByUrl = new Map();\n      this.document = this._document;\n    }\n    /** Add a SVG to the registry by passing a name and the SVG. */\n\n\n    addSvg(name, data) {\n      if (!this.iconsByUrl.has(name)) {\n        const div = this.document.createElement('DIV');\n        div.innerHTML = data;\n        const svg = div.querySelector('svg');\n        this.iconsByUrl.set(name, svg);\n      }\n    }\n    /** Load a SVG to the registry from a URL. */\n\n\n    loadSvg(url, name = url) {\n      // not sure if there should be a possibility to use name for server usage\n      // so overriding it for now if provided\n      // maybe should separate functionality for url and name use-cases\n      if (this.serverUrl && url.match(/^(http(s)?):/) === null) {\n        url = this.serverUrl + url;\n        name = url;\n      }\n\n      if (this.iconsByUrl.has(name)) {\n        return of(this.iconsByUrl.get(name));\n      } else if (this.iconsLoadingByUrl.has(name)) {\n        return this.iconsLoadingByUrl.get(name);\n      }\n\n      const o = this.loader.getSvg(url).pipe(map(svg => {\n        const div = this.document.createElement('DIV');\n        div.innerHTML = svg;\n        return div.querySelector('svg');\n      }), tap(svg => this.iconsByUrl.set(name, svg)), catchError(err => {\n        console.error(err);\n        return throwError(err);\n      }), finalize(() => this.iconsLoadingByUrl.delete(name)), share());\n      this.iconsLoadingByUrl.set(name, o);\n      return o;\n    }\n    /** Get loaded SVG from registry by name. (also works by url because of blended map) */\n\n\n    getSvgByName(name) {\n      if (this.iconsByUrl.has(name)) {\n        return of(this.iconsByUrl.get(name));\n      } else if (this.iconsLoadingByUrl.has(name)) {\n        return this.iconsLoadingByUrl.get(name);\n      }\n\n      return throwError(`No svg with name '${name}' has been loaded`);\n    }\n    /** Remove a SVG from the registry by URL (or name). */\n\n\n    unloadSvg(url) {\n      if (this.iconsByUrl.has(url)) {\n        this.iconsByUrl.delete(url);\n      }\n    }\n\n  }\n\n  SvgIconRegistryService.ɵfac = function SvgIconRegistryService_Factory(t) {\n    return new (t || SvgIconRegistryService)(i0.ɵɵinject(SvgLoader), i0.ɵɵinject(PLATFORM_ID), i0.ɵɵinject(SERVER_URL, 8), i0.ɵɵinject(DOCUMENT, 8));\n  };\n\n  SvgIconRegistryService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: SvgIconRegistryService,\n    factory: SvgIconRegistryService.ɵfac\n  });\n  return SvgIconRegistryService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction SVG_ICON_REGISTRY_PROVIDER_FACTORY(parentRegistry, loader, platformId, serverUrl, document) {\n  return parentRegistry || new SvgIconRegistryService(loader, platformId, serverUrl, document);\n}\n\nconst SVG_ICON_REGISTRY_PROVIDER = {\n  provide: SvgIconRegistryService,\n  deps: [[new Optional(), new SkipSelf(), SvgIconRegistryService], SvgLoader, [PLATFORM_ID], [new Optional(), SERVER_URL], [new Optional(), DOCUMENT]],\n  useFactory: SVG_ICON_REGISTRY_PROVIDER_FACTORY\n};\n\nclass SvgIconHelper {\n  constructor() {\n    this.loaded = false;\n  }\n\n}\n\nlet SvgIconComponent = /*#__PURE__*/(() => {\n  class SvgIconComponent {\n    constructor(element, differs, renderer, iconReg, cdr) {\n      this.element = element;\n      this.differs = differs;\n      this.renderer = renderer;\n      this.iconReg = iconReg;\n      this.cdr = cdr;\n      this.stretch = false;\n      this.applyClass = false;\n      /** @deprecated since 9.1.0 */\n\n      this.applyCss = false;\n      this.helper = new SvgIconHelper();\n      this._svgStyle = null;\n    } // Adapted from ngStyle (see:  angular/packages/common/src/directives/ng_style.ts)\n\n\n    set svgStyle(values) {\n      this._svgStyle = values;\n\n      if (!this.helper.differ && values) {\n        this.helper.differ = this.differs.find(values).create();\n      }\n    }\n\n    ngOnInit() {\n      this.init();\n    }\n\n    ngOnDestroy() {\n      this.destroy();\n    }\n\n    ngOnChanges(changeRecord) {\n      const elemSvg = this.element.nativeElement.firstChild;\n\n      if (changeRecord.src || changeRecord.name) {\n        if (this.helper.loaded) {\n          this.destroy();\n        }\n\n        this.init();\n      }\n\n      if (changeRecord.stretch) {\n        this.stylize();\n      }\n\n      if (changeRecord.applyClass) {\n        if (this.applyClass) {\n          this.setClass(elemSvg, null, this.klass);\n        } else {\n          this.setClass(elemSvg, this.klass, null);\n        }\n      }\n\n      if (changeRecord.svgClass) {\n        this.setClass(elemSvg, changeRecord.svgClass.previousValue, changeRecord.svgClass.currentValue);\n      }\n\n      if (changeRecord.klass) {\n        const elem = this.element.nativeElement;\n        this.setClass(elem, changeRecord.klass.previousValue, changeRecord.klass.currentValue);\n\n        if (this.applyClass) {\n          this.setClass(elemSvg, changeRecord.klass.previousValue, changeRecord.klass.currentValue);\n        } else {\n          this.setClass(elemSvg, changeRecord.klass.previousValue, null);\n        }\n      }\n\n      if (changeRecord.viewBox) {\n        if (this.helper.loaded) {\n          this.destroy();\n        }\n\n        this.init();\n      }\n\n      if (changeRecord.applyCss) {\n        console.warn('applyCss deprecated since 9.1.0, will be removed in 10.0.0');\n        console.warn('use applyClass instead');\n      }\n\n      if (changeRecord.svgAriaLabel) {\n        this.doAria(changeRecord.svgAriaLabel.currentValue);\n      }\n    }\n\n    ngDoCheck() {\n      if (this.helper.svg && this.helper.differ) {\n        const changes = this.helper.differ.diff(this._svgStyle);\n\n        if (changes) {\n          this.applyChanges(changes);\n        }\n      }\n    }\n\n    init() {\n      if (this.name) {\n        const svgObs = this.iconReg.getSvgByName(this.name);\n\n        if (svgObs) {\n          this.helper.icnSub = svgObs.subscribe(svg => this.initSvg(svg));\n        }\n      } else if (this.src) {\n        const svgObs = this.iconReg.loadSvg(this.src);\n\n        if (svgObs) {\n          this.helper.icnSub = svgObs.subscribe(svg => this.initSvg(svg));\n        }\n      } else {\n        const elem = this.element.nativeElement;\n        elem.innerHTML = '';\n        this.cdr.markForCheck();\n      }\n    }\n\n    initSvg(svg) {\n      if (!this.helper.loaded && svg) {\n        this.setSvg(svg);\n        this.resetDiffer();\n      }\n    }\n\n    destroy() {\n      if (this.helper.icnSub) {\n        this.helper.icnSub.unsubscribe();\n      }\n\n      this.helper = new SvgIconHelper();\n    }\n\n    resetDiffer() {\n      if (this._svgStyle && !this.helper.differ) {\n        this.helper.differ = this.differs.find(this._svgStyle).create();\n      }\n    }\n\n    setSvg(svg) {\n      if (!this.helper.loaded && svg) {\n        this.helper.svg = svg;\n        const icon = svg.cloneNode(true);\n        const elem = this.element.nativeElement;\n        elem.innerHTML = '';\n        this.renderer.appendChild(elem, icon);\n        this.helper.loaded = true;\n        this.copyNgContentAttribute(elem, icon);\n\n        if (this.klass && this.applyClass) {\n          this.setClass(elem.firstChild, null, this.klass);\n        }\n\n        if (this.svgClass) {\n          this.setClass(elem.firstChild, null, this.svgClass);\n        }\n\n        if (this.viewBox) {\n          if (this.viewBox === 'auto') {\n            // Attempt to convert height & width to a viewBox.\n            const w = icon.getAttribute('width');\n            const h = icon.getAttribute('height');\n\n            if (h && w) {\n              const vb = `0 0 ${w} ${h}`;\n              this.renderer.setAttribute(icon, 'viewBox', vb);\n              this.renderer.removeAttribute(icon, 'width');\n              this.renderer.removeAttribute(icon, 'height');\n            }\n          } else if (this.viewBox !== '') {\n            this.renderer.setAttribute(icon, 'viewBox', this.viewBox);\n            this.renderer.removeAttribute(icon, 'width');\n            this.renderer.removeAttribute(icon, 'height');\n          }\n        }\n\n        this.stylize(); // If there is not a svgAriaLabel and the SVG has an arial-label, then do not override\n        // the SVG's aria-label.\n\n        if (!(this.svgAriaLabel === undefined && elem.firstChild.hasAttribute('aria-label'))) {\n          this.doAria(this.svgAriaLabel || '');\n        }\n\n        this.cdr.markForCheck();\n      }\n    }\n\n    copyNgContentAttribute(hostElem, icon) {\n      const attributes = hostElem.attributes;\n      const len = attributes.length;\n\n      for (let i = 0; i < len; i += 1) {\n        const attribute = attributes.item(i);\n\n        if (attribute && attribute.name.startsWith('_ngcontent')) {\n          this.setNgContentAttribute(icon, attribute.name);\n          break;\n        }\n      }\n    }\n\n    setNgContentAttribute(parent, attributeName) {\n      this.renderer.setAttribute(parent, attributeName, '');\n      const len = parent.childNodes.length;\n\n      for (let i = 0; i < len; i += 1) {\n        const child = parent.childNodes[i];\n\n        if (child instanceof Element) {\n          this.setNgContentAttribute(child, attributeName);\n        }\n      }\n    }\n\n    stylize() {\n      if (this.helper.svg) {\n        const svg = this.element.nativeElement.firstChild;\n\n        if (this.stretch === true) {\n          this.renderer.setAttribute(svg, 'preserveAspectRatio', 'none');\n        } else if (this.stretch === false) {\n          this.renderer.removeAttribute(svg, 'preserveAspectRatio');\n        }\n      }\n    }\n\n    applyChanges(changes) {\n      changes.forEachRemovedItem(record => this.setStyle(record.key, null));\n      changes.forEachAddedItem(record => this.setStyle(record.key, record.currentValue));\n      changes.forEachChangedItem(record => this.setStyle(record.key, record.currentValue));\n    }\n\n    setStyle(nameAndUnit, value) {\n      const [name, unit] = nameAndUnit.split('.');\n      value = value !== null && unit ? `${value}${unit}` : value;\n      const svg = this.element.nativeElement.firstChild;\n\n      if (value !== null) {\n        this.renderer.setStyle(svg, name, value);\n      } else {\n        this.renderer.removeStyle(svg, name);\n      }\n    }\n\n    setClass(target, previous, current) {\n      if (target) {\n        if (previous) {\n          const klasses = (Array.isArray(previous) ? previous : previous.split(' ')).filter(klass => klass);\n\n          for (const k of klasses) {\n            this.renderer.removeClass(target, k);\n          }\n        }\n\n        if (current) {\n          const klasses = (Array.isArray(current) ? current : current.split(' ')).filter(klass => klass);\n\n          for (const k of klasses) {\n            this.renderer.addClass(target, k);\n          }\n        }\n      }\n    }\n\n    doAria(label) {\n      const svg = this.element.nativeElement.firstChild;\n\n      if (svg) {\n        if (label === '') {\n          this.renderer.setAttribute(svg, 'aria-hidden', 'true');\n          this.renderer.removeAttribute(svg, 'aria-label');\n        } else {\n          this.renderer.removeAttribute(svg, 'aria-hidden');\n          this.renderer.setAttribute(svg, 'aria-label', label);\n        }\n      }\n    }\n\n  }\n\n  SvgIconComponent.ɵfac = function SvgIconComponent_Factory(t) {\n    return new (t || SvgIconComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.KeyValueDiffers), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(SvgIconRegistryService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n\n  SvgIconComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: SvgIconComponent,\n    selectors: [[\"svg-icon\"]],\n    inputs: {\n      src: \"src\",\n      name: \"name\",\n      stretch: \"stretch\",\n      applyClass: \"applyClass\",\n      applyCss: \"applyCss\",\n      svgClass: \"svgClass\",\n      klass: [\"class\", \"klass\"],\n      viewBox: \"viewBox\",\n      svgAriaLabel: \"svgAriaLabel\",\n      svgStyle: \"svgStyle\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function SvgIconComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return SvgIconComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet AngularSvgIconModule = /*#__PURE__*/(() => {\n  class AngularSvgIconModule {\n    static forRoot(config = {}) {\n      return {\n        ngModule: AngularSvgIconModule,\n        providers: [SVG_ICON_REGISTRY_PROVIDER, config.loader || {\n          provide: SvgLoader,\n          useClass: SvgHttpLoader\n        }]\n      };\n    }\n\n  }\n\n  AngularSvgIconModule.ɵfac = function AngularSvgIconModule_Factory(t) {\n    return new (t || AngularSvgIconModule)();\n  };\n\n  AngularSvgIconModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: AngularSvgIconModule\n  });\n  AngularSvgIconModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return AngularSvgIconModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { AngularSvgIconModule, SERVER_URL, SVG_ICON_REGISTRY_PROVIDER, SVG_ICON_REGISTRY_PROVIDER_FACTORY, SvgHttpLoader, SvgIconComponent, SvgIconRegistryService, SvgLoader };","map":null,"metadata":{},"sourceType":"module"}