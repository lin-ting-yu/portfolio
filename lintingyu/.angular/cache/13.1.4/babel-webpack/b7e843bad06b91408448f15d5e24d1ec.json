{"ast":null,"code":"import * as i0 from \"@angular/core\";\nimport * as i1 from \"ngx-device-detector\";\nexport let ToolFunctionService = /*#__PURE__*/(() => {\n  class ToolFunctionService {\n    constructor(deviceService) {\n      this.deviceService = deviceService;\n      this.deviceInfo = null;\n      this.DETECTOR = this.epicFunction();\n    } // 判斷裝置\n\n\n    epicFunction() {\n      this.deviceInfo = this.deviceService.getDeviceInfo();\n      const isMobile = this.deviceService.isMobile();\n      const isTablet = this.deviceService.isTablet();\n      const isDesktopDevice = this.deviceService.isDesktop();\n      return {\n        isMobile,\n        isTablet,\n        isDesktopDevice\n      };\n    } // 取得樣式\n\n\n    getStyle(el, styleProp) {\n      let value,\n          defaultView = (el.ownerDocument || document).defaultView; // W3C standard way:\n\n      if (defaultView && defaultView.getComputedStyle) {\n        // sanitize property name to css notation\n        // (hypen separated words eg. font-Size)\n        styleProp = styleProp.replace(/([A-Z])/g, \"-$1\").toLowerCase();\n        return defaultView.getComputedStyle(el, null).getPropertyValue(styleProp);\n      } else if (el.currentStyle) {\n        // IE\n        // sanitize property name to camelCase\n        styleProp = styleProp.replace(/\\-(\\w)/g, function (str, letter) {\n          return letter.toUpperCase();\n        });\n        value = el.currentStyle[styleProp]; // convert other units to pixels on IE\n\n        if (/^\\d+(em|pt|%|ex)?$/i.test(value)) {\n          return function (value) {\n            let oldLeft = el.style.left,\n                oldRsLeft = el.runtimeStyle.left;\n            el.runtimeStyle.left = el.currentStyle.left;\n            el.style.left = value || 0;\n            value = el.style.pixelLeft + \"px\";\n            el.style.left = oldLeft;\n            el.runtimeStyle.left = oldRsLeft;\n            return value;\n          }(value);\n        }\n\n        return value;\n      }\n    } // 取得Transform rotate\n\n\n    getTransform(obj) {\n      let matrix = this.getStyle(obj, 'transform');\n      let rotateX = 0;\n      let rotateY = 0;\n      let rotateZ = 0;\n\n      if (matrix !== 'none') {\n        // do some magic\n        let values = matrix.split('(')[1].split(')')[0].split(',');\n        let pi = Math.PI;\n        let sinB = parseFloat(values[8]);\n        let b = Math.round(Math.asin(sinB) * 180 / pi);\n        let cosB = Math.cos(b * pi / 180);\n        let matrixVal10 = parseFloat(values[9]);\n        let a = Math.round(Math.asin(-matrixVal10 / cosB) * 180 / pi);\n        let matrixVal1 = parseFloat(values[0]);\n        let c = Math.round(Math.acos(matrixVal1 / cosB) * 180 / pi);\n        rotateX = a;\n        rotateY = b;\n        rotateZ = c;\n      }\n\n      return {\n        rotateX,\n        rotateY,\n        rotateZ\n      };\n    } // 判斷是否為DOM物件\n\n\n    isDOM(HTMLElement) {\n      let isDOM = typeof HTMLElement === 'object' ? function (obj) {\n        return obj instanceof HTMLElement;\n      } : function (obj) {\n        return obj && typeof obj === 'object' && obj.nodeType === 1 && typeof obj.nodeName === 'string';\n      };\n      return isDOM;\n    } // 重複獲取直到獲取到\n\n\n    reCheck(parent, bool, success, fail, lime) {\n      let times = 0;\n      let reCheck = setInterval(() => {\n        if (bool.call(parent)) {\n          success.call(parent);\n          clearInterval(reCheck);\n        } else if (lime && ++times > lime) {\n          fail.call(parent);\n          clearInterval(reCheck);\n        }\n      }, 10);\n    } // 設定svg尺寸\n\n\n    getSvgSize(svgComp, callback) {\n      if (svgComp) {\n        // this.windowWidth = window.innerWidth;\n        let svgDOM = svgComp.querySelector('svg');\n\n        if (svgDOM) {\n          let result;\n          let svgWidth = parseFloat(svgDOM.getAttribute('width'));\n          let svgHeight = parseFloat(svgDOM.getAttribute('height'));\n          let parent = svgComp.offsetParent;\n          let parentPL = parseFloat(this.getStyle(parent, 'padding-left'));\n          let parentPR = parseFloat(this.getStyle(parent, 'padding-right'));\n          let parentClientRect = parent.getBoundingClientRect();\n          let parentWidth = parentClientRect.width;\n          let resultWidth = parentWidth - parentPL - parentPR;\n          result = {\n            width: resultWidth,\n            height: parentWidth / svgWidth * svgHeight,\n            percen: resultWidth / svgWidth,\n            originSvgSize: {\n              width: svgWidth,\n              height: svgHeight\n            }\n          };\n\n          if (callback) {\n            callback();\n          }\n\n          return result;\n        }\n      }\n\n      return {\n        width: 0,\n        height: 0,\n        percen: 1\n      };\n    }\n\n  }\n\n  ToolFunctionService.ɵfac = function ToolFunctionService_Factory(t) {\n    return new (t || ToolFunctionService)(i0.ɵɵinject(i1.DeviceDetectorService));\n  };\n\n  ToolFunctionService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: ToolFunctionService,\n    factory: ToolFunctionService.ɵfac,\n    providedIn: 'root'\n  });\n  return ToolFunctionService;\n})();","map":null,"metadata":{},"sourceType":"module"}