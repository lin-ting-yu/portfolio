{"ast":null,"code":"import * as i0 from \"@angular/core\";\nexport let CanvasEventService = /*#__PURE__*/(() => {\n  class CanvasEventService {\n    constructor() {\n      this.targetPos = null;\n    }\n\n    setTargetPos(target) {\n      this.targetPos = target.getBoundingClientRect();\n    }\n\n    bindingMouseMove(event) {\n      if (this.targetPos === null) {\n        this.setTargetPos(event.target);\n      }\n\n      const innerPageX = typeof event.pageX === 'number' ? event.pageX : event.touches[0].pageX;\n      const innerPageY = typeof event.pageY === 'number' ? event.pageY : event.touches[0].pageY;\n      const mousePos = {\n        x: (innerPageX - this.targetPos.left) * window.devicePixelRatio,\n        y: (innerPageY - this.targetPos.top) * window.devicePixelRatio\n      }; // console.log(mousePos,this.targetPos);\n\n      return mousePos;\n    }\n\n    _style(ctx, style) {\n      if (style) {\n        const keys = Object.keys(style); // tslint:disable-next-line: prefer-for-of\n\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i];\n\n          if (ctx[key]) {\n            ctx[key] = style[key];\n          }\n        }\n      }\n    }\n\n    dorwDot(ctx, vector, radius = 10, style) {\n      ctx.save();\n      ctx.beginPath();\n\n      this._style(ctx, style);\n\n      ctx.arc(vector.x, vector.y, radius, 0, 2 * Math.PI);\n\n      if (style.drowStroke) {\n        ctx.stroke();\n      }\n\n      if (style.drowFill) {\n        ctx.fill();\n      }\n\n      ctx.closePath();\n      ctx.restore();\n    }\n\n    dorwPath(ctx, dots, closePath, style) {\n      ctx.beginPath();\n      ctx.save();\n      ctx.beginPath();\n\n      this._style(ctx, style);\n\n      for (let i = 0, jlen = dots.length; i <= jlen; ++i) {\n        if (!closePath && (i + 0 >= jlen || i + 1 >= jlen)) {\n          break;\n        }\n\n        const p0 = dots[i + 0 >= jlen ? i + 0 - jlen : i + 0];\n        const p1 = dots[i + 1 >= jlen ? i + 1 - jlen : i + 1];\n        ctx.quadraticCurveTo(p0.x, p0.y, (p0.x + p1.x) * 0.5, (p0.y + p1.y) * 0.5);\n      }\n\n      if (style.drowStroke) {\n        ctx.lineWidth = 1.2 * window.devicePixelRatio;\n        ctx.stroke();\n      }\n\n      if (style.drowFill) {\n        ctx.fill();\n      }\n\n      if (closePath) {\n        ctx.closePath();\n      }\n\n      ctx.restore();\n    }\n\n    dotInteractive(dot, // 點位置\n    active, // 互動單位位置\n    power = 2000, attract = true) {\n      let activeToDotX = dot.transformX - active.x;\n      let activeToDotY = dot.transformY - active.y;\n      const activeToDotXAbs = Math.abs(activeToDotX);\n      const activeToDotYAbs = Math.abs(activeToDotY); // 避免距離過近\n\n      const soClose = 20;\n\n      if (activeToDotXAbs < soClose && activeToDotYAbs < soClose) {\n        if (activeToDotX === 0 || activeToDotY === 0) {\n          if (activeToDotX === 0) {\n            activeToDotX + 1;\n          } else {\n            activeToDotY + 1;\n          }\n        }\n\n        if (activeToDotX > 0) {\n          activeToDotX = soClose;\n        } else {\n          activeToDotX = -soClose;\n        }\n\n        if (activeToDotY > 0) {\n          activeToDotY = soClose;\n        } else {\n          activeToDotY = -soClose;\n        }\n      } // 算出滑鼠與球距離\n\n\n      const activeToDotLength = Math.sqrt(activeToDotX * activeToDotX + activeToDotY * activeToDotY); // 算出滑鼠與球角度\n\n      let ballAngle = Math.atan2(activeToDotY, activeToDotX);\n      const GforBall = power / activeToDotLength; // 算出球與目標終點距離\n\n      let ballEndLong = attract ? activeToDotLength + GforBall : activeToDotLength - GforBall;\n      const result = {\n        x: active.x + ballEndLong * Math.cos(ballAngle),\n        y: active.y + ballEndLong * Math.sin(ballAngle)\n      };\n\n      if (!attract) {\n        ballAngle += Math.PI;\n        ballEndLong = GforBall - activeToDotLength;\n      }\n\n      return result;\n    }\n\n  }\n\n  CanvasEventService.ɵfac = function CanvasEventService_Factory(t) {\n    return new (t || CanvasEventService)();\n  };\n\n  CanvasEventService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: CanvasEventService,\n    factory: CanvasEventService.ɵfac,\n    providedIn: 'root'\n  });\n  return CanvasEventService;\n})();","map":null,"metadata":{},"sourceType":"module"}